#include <algorithm>
#include <cstring>
#include <iostream>
#include <libgen.h>
#include <string>
#include <sstream>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include <unordered_map>
#include "common.hpp"
#include "annotation.hpp"
#include "options.hpp"

using namespace std;

string wrap_help(const string& option, const string& text, const unsigned short int max_line_width) {
	istringstream iss(text);
	string result = " " + option + "  ";
	string indent(result.length(), ' ');
	unsigned short int line_width = result.length();
	while (iss && iss.tellg() != -1) {
		if (iss.str().substr(iss.tellg(), 1) == "\n") {
			result += "\n" + indent;
			line_width = indent.length();
		}
		string word;
		iss >> word;
		if (word.length() + line_width > max_line_width) {
			result += "\n" + indent;
			line_width = indent.length();
		}
		result += word + " ";
		line_width += word.length();
	}
	return result + "\n\n";
}

bool output_directory_exists(const string& output_file) {
	if (output_file.empty())
		return false;
	char* output_file_c_str = strdup(output_file.c_str()); // we need to make a copy, because dirname does not take const argument
	char* output_directory = dirname(output_file_c_str);
	struct stat file_info;
	bool result = stat(output_directory, &file_info) == 0 && (file_info.st_mode & S_IFDIR);
	free(output_file_c_str);
	return result;
}

bool validate_int(const char* optarg, int& value, const int min_value, const int max_value) {
	if (!str_to_int(optarg, value))
		return false;
	return value >= min_value && value <= max_value;
}

bool validate_int(const char* optarg, unsigned int& value, const unsigned int min_value, const unsigned int max_value) {
	int signed_int;
	if (validate_int(optarg, signed_int, min_value, max_value)) {
		value = signed_int;
		return true;
	} else
		return false;
}

bool validate_float(const char* optarg, float& value, const float min_value, const float max_value) {
	if (!str_to_float(optarg, value))
		return false;
	return value >= min_value && value <= max_value;
}

options_t get_default_options() {
	options_t options;

	options.interesting_contigs = "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 X Y AC_* NC_*";
	options.viral_contigs = "AC_* NC_*";
	options.top_viral_contigs = 5;
	options.viral_contig_min_covered_fraction = 0.05;
	for (size_t i = 0; i < FILTERS.size(); ++i)
		if (i != FILTER_none)
			options.filters[FILTERS[i]] = true;
	options.evalue_cutoff = 0.3;
	options.min_support = 2;
	options.max_mismapper_fraction = 0.8;
	options.max_homolog_identity = 0.3;
	options.min_anchor_length = 23;
	options.homopolymer_length = 6;
	options.max_genomic_breakpoint_distance = 100000;
	options.min_read_through_distance = 10000;
	options.print_extra_info_for_discarded_fusions = false;
	options.max_kmer_content = 0.6;
	options.fragment_length = 200;
	options.strandedness = STRANDEDNESS_AUTO;
	options.gtf_features = DEFAULT_GTF_FEATURES;
	options.min_spliced_events = 4;
	options.mismatch_pvalue_cutoff = 0.01;
	options.subsampling_threshold = 300;
	options.high_expression_quantile = 0.998;
	options.exonic_fraction = 0.33;
	options.external_duplicate_marking = false;
	options.fill_sequence_gaps = false;
	options.max_itd_length = 100;
	options.min_itd_allele_fraction = 0.07;
	options.min_itd_support = 10;
	options.threads = 1;

	return options;
}

void print_usage() {

	options_t default_options = get_default_options();
	string valid_filters;
	for (auto i = default_options.filters.begin(); i != default_options.filters.end(); ++i) {
		if (i != default_options.filters.begin())
			valid_filters += ", ";
		valid_filters += i->first;
	}

	cout << endl
	     << "Arriba gene fusion detector" << endl
	     << "---------------------------" << endl
	     << "Version: " << ARRIBA_VERSION << endl << endl
	     << "Arriba is a fast tool to search for aberrant transcripts such as gene fusions. " << endl
	     << "It is based on chimeric alignments found by the STAR RNA-Seq aligner." << endl
	     << endl
	     << "Usage: arriba [-c Chimeric.out.sam] -x Aligned.out.bam \\" << endl
	     << "              -g annotation.gtf -a assembly.fa [-b blacklists.tsv] [-k known_fusions.tsv] \\" << endl
	     << "              [-t tags.tsv] [-p protein_domains.gff3] [-d structural_variants_from_WGS.tsv] \\" << endl
	     << "              -o fusions.tsv [-O fusions.discarded.tsv] \\" << endl
	     << "              [OPTIONS]" << endl
	     << endl
	     << wrap_help("-c FILE", "File in SAM/BAM/CRAM format with chimeric alignments as "
	                  "generated by STAR (Chimeric.out.sam). This parameter is only required, "
	                  "if STAR was run with the parameter '--chimOutType SeparateSAMold'. "
	                  "When STAR was run with the parameter '--chimOutType WithinBAM', it "
	                  "suffices to pass the parameter -x to Arriba and -c can be omitted.")
	     << wrap_help("-x FILE", "File in SAM/BAM/CRAM format with main alignments as "
	                  "generated by STAR (Aligned.out.sam). Arriba extracts candidate reads "
	                  "from this file.")
	     << wrap_help("-g FILE", "GTF file with gene annotation. The file may be gzip-compressed.")
	     << wrap_help("-G GTF_FEATURES", "Comma-/space-separated list of names of GTF features.\n"
	                  "Default: " + default_options.gtf_features)
	     << wrap_help("-a FILE", "FastA file with genome sequence (assembly). "
	                  "The file may be gzip-compressed. An index with the file extension .fai "
	                  "must exist only if CRAM files are processed.")
	     << wrap_help("-b FILE", "File containing blacklisted events (recurrent artifacts "
	                  "and transcripts observed in healthy tissue).")
	     << wrap_help("-k FILE", "File containing known/recurrent fusions. Some cancer "
	                  "entities are often characterized by fusions between the same pair of genes. "
	                  "In order to boost sensitivity, a list of known fusions can be supplied using this parameter. "
	                  "The list must contain two columns with the names of the fused genes, "
	                  "separated by tabs.")
	     << wrap_help("-o FILE", "Output file with fusions that have passed all filters.")
	     << wrap_help("-O FILE", "Output file with fusions that were discarded due to filtering.")
	     << wrap_help("-t FILE", "Tab-separated file containing fusions to annotate with tags "
	                  "in the 'tags' column. The first two columns specify the genes; the third "
	                  "column specifies the tag. The file may be gzip-compressed.")
	     << wrap_help("-p FILE", "File in GFF3 format containing coordinates of the protein domains "
	                  "of genes. The protein domains retained in a fusion are listed in the "
	                  "column 'retained_protein_domains'. The file may be gzip-compressed.")
	     << wrap_help("-d FILE", "Tab-separated file with coordinates of structural variants "
	                  "found using whole-genome sequencing data. These coordinates serve to "
	                  "increase sensitivity towards weakly expressed fusions and to eliminate "
	                  "fusions with low evidence.")
	     << wrap_help("-D MAX_GENOMIC_BREAKPOINT_DISTANCE", "When a file with genomic breakpoints "
	                  "obtained via whole-genome sequencing is supplied via the -d parameter, "
	                  "this parameter determines how far a genomic breakpoint may be away from "
	                  "a transcriptomic breakpoint to consider it as a related event. "
	                  "For events inside genes, the distance is added to the end of the gene; "
	                  "for intergenic events, the distance threshold is applied as is. Default: " +
	                  to_string(static_cast<long long unsigned int>(default_options.max_genomic_breakpoint_distance)))
	     << wrap_help("-s STRANDEDNESS", "Whether a strand-specific protocol was used for library preparation, and if so, "
	                  "the type of strandedness (auto/yes/no/reverse). When unstranded data is processed, the strand "
	                  "can sometimes be inferred from splice-patterns. But in unclear situations, stranded "
	                  "data helps resolve ambiguities. Default: " + string((default_options.strandedness == STRANDEDNESS_NO) ? "no" : ((default_options.strandedness == STRANDEDNESS_YES) ? "yes" : ((default_options.strandedness == STRANDEDNESS_REVERSE) ? "reverse" : "auto"))))
	     << wrap_help("-i CONTIGS", "Comma-/space-separated list of interesting contigs. Fusions "
	                  "between genes on other contigs are ignored. Contigs can be specified with "
	                  "or without the prefix \"chr\". Asterisks (*) are treated as wild-cards.\n"
	                  "Default: " + default_options.interesting_contigs)
	     << wrap_help("-v CONTIGS", "Comma-/space-separated list of viral contigs. Asterisks (*) "
	                  "are treated as wild-cards.\nDefault: " + default_options.viral_contigs)
	     << wrap_help("-f FILTERS", "Comma-/space-separated list of filters to disable. By default "
	                  "all filters are enabled. Valid values: " + valid_filters)
	     << wrap_help("-E MAX_E-VALUE", "Arriba estimates the number of fusions with a given "
	                  "number of supporting reads which one would expect to see by random chance. "
	                  "If the expected number of fusions (e-value) is higher than this threshold, "
	                  "the fusion is discarded by the 'relative_support' filter. Note: "
	                  "Increasing this threshold can dramatically increase the "
	                  "number of false positives and may increase the runtime "
	                  "of resource-intensive steps. Fractional values are possible. Default: " + to_string(static_cast<long double>(default_options.evalue_cutoff)))
	     << wrap_help("-S MIN_SUPPORTING_READS", "The 'min_support' filter discards all fusions "
	                  "with fewer than this many supporting reads (split reads and discordant "
	                  "mates combined). Default: " + to_string(static_cast<long long unsigned int>(default_options.min_support)))
	     << wrap_help("-m MAX_MISMAPPERS", "When more than this fraction of supporting reads "
	                  "turns out to be mismappers, the 'mismappers' filter "
	                  "discards the fusion. Default: " + to_string(static_cast<long double>(default_options.max_mismapper_fraction)))
	     << wrap_help("-L MAX_HOMOLOG_IDENTITY", "Genes with more than the given fraction of "
	                  "sequence identity are considered homologs and removed by the 'homologs' "
	                  "filter. Default: " + to_string(static_cast<long double>(default_options.max_homolog_identity)))
	     << wrap_help("-H HOMOPOLYMER_LENGTH", "The 'homopolymer' filter removes breakpoints "
	                  "adjacent to homopolymers of the given length or more. Default: " + to_string(static_cast<long long unsigned int>(default_options.homopolymer_length)))
	     << wrap_help("-R READ_THROUGH_DISTANCE", "The 'read_through' filter removes read-through fusions "
	                  "where the breakpoints are less than the given distance away from each other. "
	                  "Default: " + to_string(static_cast<long long unsigned int>(default_options.min_read_through_distance)))
	     << wrap_help("-A MIN_ANCHOR_LENGTH", "Alignment artifacts are often characterized by "
	                  "split reads coming from only one gene and no discordant mates. Moreover, the split reads only "
	                  "align to a short stretch in one of the genes. The 'short_anchor' "
	                  "filter removes these fusions. This parameter sets the threshold in bp for "
	                  "what the filter considers short. Default: " + to_string(static_cast<long long unsigned int>(default_options.min_anchor_length)))
	     << wrap_help("-M MANY_SPLICED_EVENTS", "The 'many_spliced' filter recovers fusions "
	                  "between genes that have at least this many spliced breakpoints. Default: " + to_string(static_cast<long long unsigned int>(default_options.min_spliced_events)))
	     << wrap_help("-K MAX_KMER_CONTENT", "The 'low_entropy' filter removes reads with "
	                  "repetitive 3-mers. If the 3-mers make up more than the given fraction "
	                  "of the sequence, then the read is discarded. Default: " + to_string(static_cast<long double>(default_options.max_kmer_content)))
	     << wrap_help("-V MAX_MISMATCH_PVALUE", "The 'mismatches' filter uses a binomial model "
	                  "to calculate a p-value for observing a given number of mismatches in a read. "
	                  "If the number of mismatches is too high, the read is discarded. Default: " + to_string(static_cast<long double>(default_options.mismatch_pvalue_cutoff)))
	     << wrap_help("-F FRAGMENT_LENGTH", "When paired-end data is given, the fragment length "
	                  "is estimated automatically and this parameter has no effect. But when "
	                  "single-end data is given, the mean fragment length should be specified "
	                  "to effectively filter fusions that arise from hairpin structures. "
	                  "Default: " + to_string(static_cast<long long unsigned int>(default_options.fragment_length)))
	     << wrap_help("-U MAX_READS", "Subsample fusions with more than the given number of "
	                  "supporting reads. This improves performance without compromising sensitivity, "
	                  "as long as the threshold is high. Counting of supporting reads beyond "
	                  "the threshold is inaccurate, obviously. "
	                  "Default: " + to_string(static_cast<long long unsigned int>(default_options.subsampling_threshold)))
	     << wrap_help("-Q QUANTILE", "Highly expressed genes are prone to produce artifacts "
	                  "during library preparation. Genes with an expression above the given quantile "
	                  "are eligible for filtering by the 'in_vitro' filter. "
	                  "Default: " + to_string(static_cast<long double>(default_options.high_expression_quantile)))
	     << wrap_help("-e EXONIC_FRACTION", "The breakpoints of false-positive predictions of "
	                  "intragenic events are often both in exons. True predictions are more likely "
	                  "to have at least one breakpoint in an intron, because introns are larger. "
	                  "If the fraction of exonic sequence between two breakpoints is smaller than "
	                  "the given fraction, the 'intragenic_exonic' filter discards the event. "
	                  "Default: " + to_string(static_cast<long double>(default_options.exonic_fraction)))
	     << wrap_help("-T TOP_N", "Only report viral integration sites of the top N most highly "
	                  "expressed viral contigs. Default: " + to_string(static_cast<long long unsigned int>(default_options.top_viral_contigs)))
	     << wrap_help("-C COVERED_FRACTION", "Ignore virally associated events if the virus is not "
	                  "fully expressed, i.e., less than the given fraction of the viral contig is "
	                  "transcribed. Default: " + to_string(static_cast<long double>(default_options.viral_contig_min_covered_fraction)))
	     << wrap_help("-l MAX_ITD_LENGTH", "Maximum length of internal tandem duplications. Note:  "
	                  "Increasing this value beyond the default can impair performance and lead to "
	                  "many false positives. Default: " + to_string(static_cast<long long unsigned int>(default_options.max_itd_length)))
	     << wrap_help("-z MIN_ITD_ALLELE_FRACTION", "Required fraction of supporting reads to "
	                  "report an internal tandem duplication. Default: " + to_string(static_cast<long double>(default_options.min_itd_allele_fraction)))
	     << wrap_help("-Z MIN_ITD_SUPPORTING_READS", "Required absolute number of supporting reads "
	                  "to report an internal tandem duplication. Default: " + to_string(static_cast<long long unsigned int>(default_options.min_itd_support)))
	     << wrap_help("-u", "Instead of performing duplicate marking itself, Arriba relies on "
	                  "duplicate marking by a preceding program using the BAM_FDUP flag. This "
	                  "makes sense when unique molecular identifiers (UMI) are used.")
	     << wrap_help("-X", "To reduce the runtime and file size, by default, the columns "
	                  "'fusion_transcript', 'peptide_sequence', and 'read_identifiers' are left "
	                  "empty in the file containing discarded fusion candidates (see parameter -O). "
	                  "When this flag is set, this extra information is reported in the discarded "
	                  "fusions file.")
	     << wrap_help("-I", "If assembly of the fusion transcript sequence from the supporting "
	                  "reads is incomplete (denoted as '...'), fill the gaps using the assembly "
	                  "sequence wherever possible.")
	     << wrap_help("-@", "Number of threads to use for BAM/CRAM file reading. Note that in most "
	                  "situations 1 thread is optimal. Values >2 almost never show further speedup.")
	     << wrap_help("-h", "Print help and exit.")
	     << "         Code repository: " << CODE_REPOSITORY << endl
	     << "    Get help/report bugs: " << HELP_CONTACT << endl
	     << "             User manual: " << USER_MANUAL << endl
	     << "             Please cite: " << CITATION << endl << endl;
}

options_t parse_arguments(int argc, char **argv) {
	options_t options = get_default_options();

	// throw error when first argument is not prefixed with a dash
	// for some reason getopt does not detect this error and simply skips the argument
	crash(argc > 1 && (string(argv[1]).empty() || argv[1][0] != '-'), "cannot interpret the first argument: " + argv[1]);

	// parse arguments
	opterr = 0;
	int c;
	string junction_suffix(".junction");
	unordered_map<char,unsigned int> duplicate_arguments;
	const string valid_arguments = "c:x:d:g:G:o:O:t:p:a:b:k:s:i:v:f:E:S:m:L:H:D:R:A:M:K:V:F:U:Q:e:T:C:l:z:Z:@:uXIh";
	while ((c = getopt(argc, argv, valid_arguments.c_str())) != -1) {

		// throw error if the same argument is specified more than once
		duplicate_arguments[c]++;
		crash(duplicate_arguments[c] > 1, "option -" + ((char) c) + " specified too often");

		switch (c) {
			case 'c':
				options.chimeric_bam_file = optarg;
				crash(access(options.chimeric_bam_file.c_str(), R_OK), "file not found/readable: " + options.chimeric_bam_file);
				if (options.chimeric_bam_file.size() >= junction_suffix.size() &&
				    options.chimeric_bam_file.substr(options.chimeric_bam_file.size() - junction_suffix.size()) == junction_suffix) {
					cerr << "WARNING: it seems you passed the chimeric junction file ('Chimeric.out.junction') to the parameter -c, but this parameter takes the chimeric alignments file ('Chimeric.out.sam') as input" << endl;
				}
				break;
			case 'x': {
				options.rna_bam_file = optarg;
				crash(access(options.rna_bam_file.c_str(), R_OK), "file not found/readable: " + options.rna_bam_file);
				break;
			}
			case 'd':
				options.genomic_breakpoints_file = optarg;
				crash(access(options.genomic_breakpoints_file.c_str(), R_OK), "file not found/readable: " + options.genomic_breakpoints_file);
				break;
			case 'g':
				options.gene_annotation_file = optarg;
				crash(access(options.gene_annotation_file.c_str(), R_OK), "file not found/readable: " + options.gene_annotation_file);
				break;
			case 'G':
				options.gtf_features = optarg;
				{
					gtf_features_t gtf_features;
					crash(!parse_gtf_features(options.gtf_features, gtf_features), "malformed GTF features: " + options.gtf_features);
				}
				break;
			case 'o':
				options.output_file = optarg;
				crash(!output_directory_exists(options.output_file), "parent directory of output file '" + options.output_file + "' does not exist");
				break;
			case 'O':
				options.discarded_output_file = optarg;
				crash(!output_directory_exists(options.discarded_output_file), "parent directory of output file '" + options.discarded_output_file + "' does not exist");
				break;
			case 't':
				options.tags_file = optarg;
				crash(access(options.tags_file.c_str(), R_OK), "file not found/readable: " + options.tags_file);
				break;
			case 'p':
				options.protein_domains_file = optarg;
				crash(access(options.protein_domains_file.c_str(), R_OK), "file not found/readable: " + options.protein_domains_file);
				break;

			case 'a':
				options.assembly_file = optarg;
				crash(access(options.assembly_file.c_str(), R_OK), "file not found/readable: " + options.assembly_file);
				// when CRAM files are used, the FastA file must be indexed
				if (options.rna_bam_file.size() >= 5 && options.rna_bam_file.substr(options.rna_bam_file.size()-5) == ".cram")
					crash(access((options.assembly_file + ".fai").c_str(), R_OK), "index file not found/readable: " + options.assembly_file + ".fai");
				break;
			case 'b':
				options.blacklist_file = optarg;
				crash(access(options.blacklist_file.c_str(), R_OK), "file not found/readable: " + options.blacklist_file);
				break;
			case 'k':
				options.known_fusions_file = optarg;
				crash(access(options.known_fusions_file.c_str(), R_OK), "file not found/readable: " + options.known_fusions_file);
				break;
			case 's':
				if (string(optarg) == "auto") {
					options.strandedness = STRANDEDNESS_AUTO;
				} else if (string(optarg) == "yes") {
					options.strandedness = STRANDEDNESS_YES;
				} else if (string(optarg) == "no") {
					options.strandedness = STRANDEDNESS_NO;
				} else if (string(optarg) == "reverse") {
					options.strandedness = STRANDEDNESS_REVERSE;
				} else {
					crash(true, "invalid type of strandedness: " + string(optarg));
				}
				break;
			case 'i':
				options.interesting_contigs = optarg;
				replace(options.interesting_contigs.begin(), options.interesting_contigs.end(), ',', ' ');
				break;
			case 'v':
				options.viral_contigs = optarg;
				replace(options.viral_contigs.begin(), options.viral_contigs.end(), ',', ' ');
				break;
			case 'f':
				{
					string disabled_filters;
					disabled_filters = optarg;
					replace(disabled_filters.begin(), disabled_filters.end(), ',', ' ');
					istringstream disabled_filters_ss;
					disabled_filters_ss.str(disabled_filters);
					while (disabled_filters_ss) {
						string disabled_filter;
						disabled_filters_ss >> disabled_filter;
						crash(!disabled_filter.empty() && options.filters.find(disabled_filter) == options.filters.end(), "invalid argument to option -f: " + disabled_filter);
						options.filters[disabled_filter] = false;
					}
				}
				break;
			case 'E':
				crash(!validate_float(optarg, options.evalue_cutoff, 0), "argument to -" + ((char) c) + " must be greater than 0");
				break;
			case 'S':
				crash(!validate_int(optarg, options.min_support, 0), "invalid argument to -" + ((char) c));
				break;
			case 'm':
				crash(!validate_float(optarg, options.max_mismapper_fraction, 0, 1), "argument to -" + ((char) c) + " must be between 0 and 1");
				break;
			case 'L':
				crash(!validate_float(optarg, options.max_homolog_identity, 0, 1), "argument to -" + ((char) c) + " must be between 0 and 1");
				break;
			case 'H':
				crash(!validate_int(optarg, options.homopolymer_length, 2), "argument to -" + ((char) c) + " must be greater than 1");
				break;
			case 'D':
				crash(!validate_int(optarg, options.max_genomic_breakpoint_distance, 0), "invalid argument to -" + ((char) c));
				break;
			case 'R':
				crash(!validate_int(optarg, options.min_read_through_distance, 0), "invalid argument to -" + ((char) c));
				break;
			case 'A':
				crash(!validate_int(optarg, options.min_anchor_length, 0), "invalid argument to -" + ((char) c));
				break;
			case 'M':
				crash(!validate_int(optarg, options.min_spliced_events, 0), "invalid argument to -" + ((char) c));
				break;
			case 'K':
				crash(!validate_float(optarg, options.max_kmer_content, 0, 1), "argument to -" + ((char) c) + " must be between 0 and 1");
				break;
			case 'V':
				crash(!validate_float(optarg, options.mismatch_pvalue_cutoff, 0, 1), "argument to -" + ((char) c) + " must be between 0 and 1");
				break;
			case 'F':
				crash(!validate_int(optarg, options.fragment_length, 1), "argument to -" + ((char) c) + " must be an integer greater than 0");
				break;
			case 'U':
				crash(!validate_int(optarg, options.subsampling_threshold, 1, SHRT_MAX), "argument to -" + ((char) c) + " must be an integer between 1 and " + to_string(SHRT_MAX));
				break;
			case 'Q':
				crash(!validate_float(optarg, options.high_expression_quantile, 0, 1), "argument to -" + ((char) c) + " must be between 0 and 1");
				break;
			case 'e':
				crash(!validate_float(optarg, options.exonic_fraction, 0, 1), "argument to -" + ((char) c) + " must be between 0 and 1");
				break;
			case 'T':
				crash(!validate_int(optarg, options.top_viral_contigs, 1), "invalid argument to -" + ((char) c));
				break;
			case 'C':
				crash(!validate_float(optarg, options.viral_contig_min_covered_fraction, 0, 1), "argument to -" + ((char) c) + " must be between 0 and 1");
				break;
			case 'l':
				crash(!validate_int(optarg, options.max_itd_length, 1), "argument to -" + ((char) c) + " must be an integer greater than 0");
				break;
			case 'z':
				crash(!validate_float(optarg, options.min_itd_allele_fraction, 0, 1), "argument to -" + ((char) c) + " must be between 0 and 1");
				break;
			case 'Z':
				crash(!validate_int(optarg, options.min_itd_support, 1), "argument to -" + ((char) c) + " must be an integer greater than 0");
				break;
			case '@':
				crash(!validate_int(optarg, options.threads, 1), "argument to -" + ((char) c) + " must be an integer greater than 0");
				break;
			case 'u':
				options.external_duplicate_marking = true;
				break;
			case 'X':
				options.print_extra_info_for_discarded_fusions = true;
				break;
			case 'I':
				options.fill_sequence_gaps = true;
				break;
			case 'h':
				print_usage();
				exit(0);
				break;
			default:
				crash(valid_arguments.find(string(1, (char) optopt) + ":") != string::npos, "option -" + ((char) optopt) + " requires an argument");
				crash(true, "unknown option: -" + ((char) optopt));
				break;
		}

		crash(optind < argc && (string(argv[optind]).empty() || argv[optind][0] != '-'), "option -" + ((char) c) + " has too many arguments (arguments with blanks must be wrapped in quotes)");

	}

	// check for mandatory arguments
	if (argc == 1) {
		print_usage();
		crash(true, "no arguments given");
	}
	crash(options.rna_bam_file.empty(), "missing mandatory option -x");
	crash(options.gene_annotation_file.empty(), "missing mandatory option -g");
	crash(options.output_file.empty(), "missing mandatory option -o");
	crash(options.assembly_file.empty(), "missing mandatory option -a");
	crash(options.filters["blacklist"] && options.blacklist_file.empty(), "filter 'blacklist' enabled, but missing option -b (use '-f blacklist' if you want to disable the blacklist)");

	return options;
}

